package genrepository

import (
	"embed"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/alexisvisco/goframe/cli/generators"
	"github.com/alexisvisco/goframe/cli/generators/genhelper"
	"github.com/alexisvisco/goframe/core/helpers/str"
	"github.com/alexisvisco/goframe/core/helpers/typeutil"
)

// RepositoryGenerator handles repository files.
type RepositoryGenerator struct {
	Gen *generators.Generator
}

//go:embed templates
var fs embed.FS

// Generate creates the initial repository infrastructure files.
func (r *RepositoryGenerator) Generate() error {
	files := []generators.FileConfig{
		r.createOrUpdateRegistry(),
	}

	if err := r.Gen.GenerateFiles(files); err != nil {
		return err
	}

	return r.updateAppModule()
}

// Update refreshes the repository registry with current repositories.
func (r *RepositoryGenerator) Update() error {
	err := r.Gen.GenerateFile(r.createOrUpdateRegistry())
	if err != nil {
		return fmt.Errorf("failed to generate registry: %w", err)
	}

	return r.updateAppModule()
}

// GenerateRepository creates a new repository with the specified name.
func (r *RepositoryGenerator) GenerateRepository(name string) error {
	files := []generators.FileConfig{
		r.createRepositoryFile(name),
		r.createOrUpdateRegistry(),
	}

	if err := r.Gen.GenerateFiles(files); err != nil {
		return err
	}

	if err := r.createOrUpdateRepositoryInterfaceAndStruct(name); err != nil {
		return fmt.Errorf("failed to ensure repository interface: %w", err)
	}

	return r.updateAppModule()
}

func (r *RepositoryGenerator) createRepositoryFile(name string) generators.FileConfig {
	path := filepath.Join("internal/repository", fmt.Sprintf("repository_%s.go", str.ToSnakeCase(name)))

	return generators.FileConfig{
		Path:     path,
		Template: typeutil.Must(fs.ReadFile("templates/new_repository.go.tmpl")),
		Gen: func(g *genhelper.GenHelper) {
			g.WithVar("name_pascal", str.ToPascalCase(name))
		},
	}
}

func (r *RepositoryGenerator) createOrUpdateRegistry() generators.FileConfig {

	return generators.FileConfig{
		Path:     "internal/repository/registry.go",
		Template: typeutil.Must(fs.ReadFile("templates/registry.go.tmpl")),
		Gen: func(g *genhelper.GenHelper) {
			repositories, _ := r.listRepositories() // Ignoring error as empty slice is acceptable if dir doesn't exist
			g.WithVar("repositories", repositories)
			if len(repositories) > 0 {
				g.WithImport(filepath.Join(r.Gen.GoModuleName, "internal/types"), "types").
					WithImport("github.com/alexisvisco/goframe/core/helpers/fxutil", "fxutil")
			}
		},
	}
}

func (r *RepositoryGenerator) createOrUpdateRepositoryInterfaceAndStruct(name string) error {
	path := filepath.Join("internal/types", fmt.Sprintf("%s.go", str.ToSnakeCase(name)))
	// check if the file exists if not create it and add package types
	if _, err := os.Stat(path); os.IsNotExist(err) {
		if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
			return fmt.Errorf("failed to create directory for types: %w", err)
		}

		f, err := os.Create(path)
		if err != nil {
			return fmt.Errorf("failed to create type file: %w", err)
		}

		if _, err := f.WriteString("// Package types ; CODE GENERATED BY goframe; DO NOT EDIT\npackage types\n"); err != nil {
			return fmt.Errorf("failed to write package declaration: %w", err)
		}

		_ = f.Close()
	}

	file, err := genhelper.LoadGoFile(path)
	if err != nil {
		return fmt.Errorf("failed to load type file: %w", err)
	}

	if !file.HasStruct(str.ToPascalCase(name)) {
		file.AddContent("type " + str.ToPascalCase(name) + " struct{}\n")
	}
	if !file.HasInterface(str.ToPascalCase(name) + "Repository") {
		file.AddContent("type " + str.ToPascalCase(name) + "Repository interface{}\n")
	}

	return file.Save()
}

func (r *RepositoryGenerator) updateAppModule() error {
	path := "internal/app/module.go"
	gf, err := genhelper.LoadGoFile(path)
	if err != nil {
		return nil // File might not exist yet, which is acceptable
	}

	gf.AddNamedImport("", filepath.Join(r.Gen.GoModuleName, "internal/repository"))
	gf.AddLineAfterString("return []fx.Option{", "\tfx.Provide(repository.Dependencies...),")

	return gf.Save()
}

func (r *RepositoryGenerator) listRepositories() ([]string, error) {
	entries, err := os.ReadDir("internal/repository")
	if err != nil {
		return nil, err
	}

	var repos []string
	for _, e := range entries {
		if e.IsDir() || filepath.Ext(e.Name()) != ".go" {
			continue
		}
		if e.Name() == "registry.go" {
			continue
		}

		name := strings.TrimSuffix(e.Name(), filepath.Ext(e.Name()))
		name = strings.TrimPrefix(name, "repository_")
		pascal := str.ToPascalCase(name)

		if !strings.HasSuffix(pascal, "Repository") {
			pascal += "Repository"
		}

		repos = append(repos, pascal)
	}

	return repos, nil
}
