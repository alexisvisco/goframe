package genservice

import (
	"embed"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/alexisvisco/goframe/cli/generators"
	"github.com/alexisvisco/goframe/cli/generators/genhelper"
	"github.com/alexisvisco/goframe/core/helpers/str"
	"github.com/alexisvisco/goframe/core/helpers/typeutil"
)

// ServiceGenerator manages service files.
type ServiceGenerator struct {
	Gen *generators.Generator
}

//go:embed templates
var fs embed.FS

// Generate creates the initial service infrastructure files.
func (s *ServiceGenerator) Generate() error {
	files := []generators.FileConfig{
		s.createOrUpdateRegistry(),
	}

	if err := s.Gen.GenerateFiles(files); err != nil {
		return err
	}

	return s.updateAppModule()
}

// Update refreshes the service registry with current services.
func (s *ServiceGenerator) Update() error {
	err := s.Gen.GenerateFile(s.createOrUpdateRegistry())
	if err != nil {
		return fmt.Errorf("failed to generate registry: %w", err)
	}

	return s.updateAppModule()
}

// GenerateService creates a new service with the specified name.
func (s *ServiceGenerator) GenerateService(name string, withRepo bool) error {
	files := []generators.FileConfig{
		s.createServiceFile(name, withRepo),
		s.createOrUpdateRegistry(),
	}

	if err := s.Gen.GenerateFiles(files); err != nil {
		return err
	}

	if err := s.createOrUpdateServiceInterface(name); err != nil {
		return fmt.Errorf("failed to ensure service interface: %w", err)
	}

	return s.updateAppModule()
}

func (s *ServiceGenerator) createServiceFile(name string, withRepo bool) generators.FileConfig {
	path := filepath.Join("internal/service", fmt.Sprintf("service_%s.go", str.ToSnakeCase(name)))

	return generators.FileConfig{
		Path:     path,
		Template: typeutil.Must(fs.ReadFile("templates/new_service.go.tmpl")),
		Gen: func(g *genhelper.GenHelper) {
			g.WithVar("name_pascal", str.ToPascalCase(name)).
				WithVar("with_repo", withRepo).
				WithImport(filepath.Join(s.Gen.GoModuleName, "internal/types"), "types")
		},
	}
}

func (s *ServiceGenerator) createOrUpdateRegistry() generators.FileConfig {

	return generators.FileConfig{
		Path:     "internal/service/registry.go",
		Template: typeutil.Must(fs.ReadFile("templates/registry.go.tmpl")),
		Gen: func(g *genhelper.GenHelper) {
			services, _ := s.listServices() // Ignoring error as empty slice is acceptable if dir doesn't exist
			g.WithVar("services", services)
			if len(services) > 0 {
				g.WithImport(filepath.Join(s.Gen.GoModuleName, "internal/types"), "types").
					WithImport("github.com/alexisvisco/goframe/core/helpers/fxutil", "fxutil")
			}
		},
	}
}

func (s *ServiceGenerator) createOrUpdateServiceInterface(name string) error {
	path := filepath.Join("internal/types", fmt.Sprintf("%s.go", str.ToSnakeCase(name)))
	// check if the file exists if not create it and add package types
	if _, err := os.Stat(path); os.IsNotExist(err) {
		if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
			return fmt.Errorf("failed to create directory for types: %w", err)
		}

		f, err := os.Create(path)
		if err != nil {
			return fmt.Errorf("failed to create type file: %w", err)
		}

		if _, err := f.WriteString("// Package types ; CODE GENERATED BY goframe; DO NOT EDIT\npackage types\n"); err != nil {
			return fmt.Errorf("failed to write package declaration: %w", err)
		}

		_ = f.Close() // Ensure the file is closed after creation
	}

	file, err := genhelper.LoadGoFile(path)
	if err != nil {
		return fmt.Errorf("failed to load type file: %w", err)
	}

	if !file.HasInterface(str.ToPascalCase(name) + "Service") {
		file.AddContent("type " + str.ToPascalCase(name) + "Service interface{}\n")
	}

	return file.Save()
}

func (s *ServiceGenerator) updateAppModule() error {
	path := "internal/app/module.go"
	gf, err := genhelper.LoadGoFile(path)
	if err != nil {
		return nil // File might not exist yet, which is acceptable
	}

	gf.AddNamedImport("", filepath.Join(s.Gen.GoModuleName, "internal/service"))
	gf.AddLineAfterString("return []fx.Option{", "\tfx.Provide(service.Dependencies...),")

	return gf.Save()
}

func (s *ServiceGenerator) listServices() ([]string, error) {
	entries, err := os.ReadDir("internal/service")
	if err != nil {
		return nil, err
	}

	var services []string
	for _, e := range entries {
		if e.IsDir() || filepath.Ext(e.Name()) != ".go" {
			continue
		}
		if e.Name() == "registry.go" {
			continue
		}

		name := strings.TrimSuffix(e.Name(), filepath.Ext(e.Name()))
		name = strings.TrimPrefix(name, "service_")
		pascal := str.ToPascalCase(name)

		if !strings.HasSuffix(pascal, "Service") {
			pascal += "Service"
		}

		services = append(services, pascal)
	}

	return services, nil
}
