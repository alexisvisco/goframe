# Dependency Injection

We use uber [fx](...) to managee dependencies and lifecycle of the application.

## How FX works with GoFrame

We choose uber fx as the dependency injection framework for GoFrame. It allows us to manage dependencies and application lifecycle in a structured way.
All dependencies are in the internal/app package with the `Module` function.

We choose a pattern where each internal packages has a registry file that list dependencies and we are able to inject them in the app package.

This allow easy management of dependencies because if you need for instance only all repositories you can easily do `fx.Provide(repository.Dependencies...)` and that's it.

Registry files are generated by the CLI when you generate code so you don't need to touch them manually.


## Example

To add a dependency in the app package, you can use the `fx.Provide` function. For example, if you want to add a repository dependency, you can do it like this:

```go
type Type1 struct {}

func MyConstructor() *Type1 {
	return &Type1{}
}

type Type2 struct {
	Dependency *Type1
}

func MyConstructor2(t1 *Type1) *Type2 {
	return &Type2{
		Dependency: t1,
	}
}

func Module(cfg *config.Config) []fx.Option {
	return []fx.Option{
		fx.Provide(MyConstructor), // You could also do fx.Supply(&Type1{}) because it's a no argument constructor
		fx.Provide(MyConstructor2),
	}
}
```

This will create a `Type2` instance with a dependency on `Type1`. The `fx.Provide` function automatically resolves the dependencies and injects them into the constructors.

I recommend you to check the [fx documentation](https://pkg.go.dev/go.uber.org/fx) for more details on how to use it and its features.
